/**
 * C++ code implementations for data structures
 * Each data structure includes line-by-line step mappings
 */

import { AlgorithmCode } from './algorithmCode';

export const dataStructureCodes: Record<string, AlgorithmCode> = {
  'stack': {
    algorithmId: 'stack',
    language: 'cpp',
    code: [
      { line: 1, code: 'class Stack {', indent: 0 },
      { line: 2, code: 'private:', indent: 0 },
      { line: 3, code: 'vector<int> data;', indent: 1 },
      { line: 4, code: '', indent: 0 },
      { line: 5, code: 'public:', indent: 0 },
      { line: 6, code: 'void push(int value) {', indent: 1 },
      { line: 7, code: 'data.push_back(value);', indent: 2 },
      { line: 8, code: '}', indent: 1 },
      { line: 9, code: '', indent: 0 },
      { line: 10, code: 'int pop() {', indent: 1 },
      { line: 11, code: 'if (isEmpty()) throw "Stack empty";', indent: 2 },
      { line: 12, code: 'int val = data.back();', indent: 2 },
      { line: 13, code: 'data.pop_back();', indent: 2 },
      { line: 14, code: 'return val;', indent: 2 },
      { line: 15, code: '}', indent: 1 },
      { line: 16, code: '', indent: 0 },
      { line: 17, code: 'int top() {', indent: 1 },
      { line: 18, code: 'if (isEmpty()) throw "Stack empty";', indent: 2 },
      { line: 19, code: 'return data.back();', indent: 2 },
      { line: 20, code: '}', indent: 1 },
      { line: 21, code: '', indent: 0 },
      { line: 22, code: 'bool isEmpty() {', indent: 1 },
      { line: 23, code: 'return data.empty();', indent: 2 },
      { line: 24, code: '}', indent: 1 },
      { line: 25, code: '};', indent: 0 },
    ],
    stepToLineMap: {
      'push': [6, 7],
      'pop': [10, 11, 12, 13, 14],
      'top': [17, 18, 19],
      'isEmpty': [22, 23],
    }
  },

  'queue': {
    algorithmId: 'queue',
    language: 'cpp',
    code: [
      { line: 1, code: 'class Queue {', indent: 0 },
      { line: 2, code: 'private:', indent: 0 },
      { line: 3, code: 'vector<int> data;', indent: 1 },
      { line: 4, code: '', indent: 0 },
      { line: 5, code: 'public:', indent: 0 },
      { line: 6, code: 'void enqueue(int value) {', indent: 1 },
      { line: 7, code: 'data.push_back(value);', indent: 2 },
      { line: 8, code: '}', indent: 1 },
      { line: 9, code: '', indent: 0 },
      { line: 10, code: 'int dequeue() {', indent: 1 },
      { line: 11, code: 'if (isEmpty()) throw "Queue empty";', indent: 2 },
      { line: 12, code: 'int val = data.front();', indent: 2 },
      { line: 13, code: 'data.erase(data.begin());', indent: 2 },
      { line: 14, code: 'return val;', indent: 2 },
      { line: 15, code: '}', indent: 1 },
      { line: 16, code: '', indent: 0 },
      { line: 17, code: 'int front() {', indent: 1 },
      { line: 18, code: 'if (isEmpty()) throw "Queue empty";', indent: 2 },
      { line: 19, code: 'return data.front();', indent: 2 },
      { line: 20, code: '}', indent: 1 },
      { line: 21, code: '', indent: 0 },
      { line: 22, code: 'bool isEmpty() {', indent: 1 },
      { line: 23, code: 'return data.empty();', indent: 2 },
      { line: 24, code: '}', indent: 1 },
      { line: 25, code: '};', indent: 0 },
    ],
    stepToLineMap: {
      'enqueue': [6, 7],
      'dequeue': [10, 11, 12, 13, 14],
      'front': [17, 18, 19],
      'isEmpty': [22, 23],
    }
  },

  'linked-list': {
    algorithmId: 'linked-list',
    language: 'cpp',
    code: [
      { line: 1, code: 'struct Node {', indent: 0 },
      { line: 2, code: 'int data;', indent: 1 },
      { line: 3, code: 'Node* next;', indent: 1 },
      { line: 4, code: 'Node(int val) : data(val), next(nullptr) {}', indent: 1 },
      { line: 5, code: '};', indent: 0 },
      { line: 6, code: '', indent: 0 },
      { line: 7, code: 'class LinkedList {', indent: 0 },
      { line: 8, code: 'private:', indent: 0 },
      { line: 9, code: 'Node* head;', indent: 1 },
      { line: 10, code: '', indent: 0 },
      { line: 11, code: 'public:', indent: 0 },
      { line: 12, code: 'void insert(int value) {', indent: 1 },
      { line: 13, code: 'Node* newNode = new Node(value);', indent: 2 },
      { line: 14, code: 'if (!head) {', indent: 2 },
      { line: 15, code: 'head = newNode;', indent: 3 },
      { line: 16, code: '} else {', indent: 2 },
      { line: 17, code: 'Node* temp = head;', indent: 3 },
      { line: 18, code: 'while (temp->next) temp = temp->next;', indent: 3 },
      { line: 19, code: 'temp->next = newNode;', indent: 3 },
      { line: 20, code: '}', indent: 2 },
      { line: 21, code: '}', indent: 1 },
      { line: 22, code: '', indent: 0 },
      { line: 23, code: 'void remove() {', indent: 1 },
      { line: 24, code: 'if (!head) return;', indent: 2 },
      { line: 25, code: 'Node* temp = head;', indent: 2 },
      { line: 26, code: 'head = head->next;', indent: 2 },
      { line: 27, code: 'delete temp;', indent: 2 },
      { line: 28, code: '}', indent: 1 },
      { line: 29, code: '};', indent: 0 },
    ],
    stepToLineMap: {
      'insert': [12, 13, 14, 15, 17, 18, 19],
      'remove': [23, 24, 25, 26, 27],
    }
  },

  'bst': {
    algorithmId: 'bst',
    language: 'cpp',
    code: [
      { line: 1, code: 'struct TreeNode {', indent: 0 },
      { line: 2, code: 'int data;', indent: 1 },
      { line: 3, code: 'TreeNode *left, *right;', indent: 1 },
      { line: 4, code: 'TreeNode(int val) : data(val), left(nullptr), right(nullptr) {}', indent: 1 },
      { line: 5, code: '};', indent: 0 },
      { line: 6, code: '', indent: 0 },
      { line: 7, code: 'class BST {', indent: 0 },
      { line: 8, code: 'private:', indent: 0 },
      { line: 9, code: 'TreeNode* root;', indent: 1 },
      { line: 10, code: '', indent: 0 },
      { line: 11, code: 'TreeNode* insert(TreeNode* node, int value) {', indent: 1 },
      { line: 12, code: 'if (!node) return new TreeNode(value);', indent: 2 },
      { line: 13, code: '', indent: 0 },
      { line: 14, code: 'if (value < node->data)', indent: 2 },
      { line: 15, code: 'node->left = insert(node->left, value);', indent: 3 },
      { line: 16, code: 'else', indent: 2 },
      { line: 17, code: 'node->right = insert(node->right, value);', indent: 3 },
      { line: 18, code: '', indent: 0 },
      { line: 19, code: 'return node;', indent: 2 },
      { line: 20, code: '}', indent: 1 },
      { line: 21, code: '', indent: 0 },
      { line: 22, code: 'public:', indent: 0 },
      { line: 23, code: 'void insert(int value) {', indent: 1 },
      { line: 24, code: 'root = insert(root, value);', indent: 2 },
      { line: 25, code: '}', indent: 1 },
      { line: 26, code: '};', indent: 0 },
    ],
    stepToLineMap: {
      'insert': [11, 12, 14, 15, 17, 19],
      'traverse': [14, 15, 17],
    }
  },

  'heap': {
    algorithmId: 'heap',
    language: 'cpp',
    code: [
      { line: 1, code: 'class MinHeap {', indent: 0 },
      { line: 2, code: 'private:', indent: 0 },
      { line: 3, code: 'vector<int> heap;', indent: 1 },
      { line: 4, code: '', indent: 0 },
      { line: 5, code: 'void heapifyUp(int idx) {', indent: 1 },
      { line: 6, code: 'int parent = (idx - 1) / 2;', indent: 2 },
      { line: 7, code: 'if (idx > 0 && heap[idx] < heap[parent]) {', indent: 2 },
      { line: 8, code: 'swap(heap[idx], heap[parent]);', indent: 3 },
      { line: 9, code: 'heapifyUp(parent);', indent: 3 },
      { line: 10, code: '}', indent: 2 },
      { line: 11, code: '}', indent: 1 },
      { line: 12, code: '', indent: 0 },
      { line: 13, code: 'void heapifyDown(int idx) {', indent: 1 },
      { line: 14, code: 'int left = 2 * idx + 1;', indent: 2 },
      { line: 15, code: 'int right = 2 * idx + 2;', indent: 2 },
      { line: 16, code: 'int smallest = idx;', indent: 2 },
      { line: 17, code: '', indent: 0 },
      { line: 18, code: 'if (left < heap.size() && heap[left] < heap[smallest])', indent: 2 },
      { line: 19, code: 'smallest = left;', indent: 3 },
      { line: 20, code: 'if (right < heap.size() && heap[right] < heap[smallest])', indent: 2 },
      { line: 21, code: 'smallest = right;', indent: 3 },
      { line: 22, code: '', indent: 0 },
      { line: 23, code: 'if (smallest != idx) {', indent: 2 },
      { line: 24, code: 'swap(heap[idx], heap[smallest]);', indent: 3 },
      { line: 25, code: 'heapifyDown(smallest);', indent: 3 },
      { line: 26, code: '}', indent: 2 },
      { line: 27, code: '}', indent: 1 },
      { line: 28, code: '', indent: 0 },
      { line: 29, code: 'public:', indent: 0 },
      { line: 30, code: 'void insert(int value) {', indent: 1 },
      { line: 31, code: 'heap.push_back(value);', indent: 2 },
      { line: 32, code: 'heapifyUp(heap.size() - 1);', indent: 2 },
      { line: 33, code: '}', indent: 1 },
      { line: 34, code: '', indent: 0 },
      { line: 35, code: 'int extractMin() {', indent: 1 },
      { line: 36, code: 'if (heap.empty()) throw "Heap empty";', indent: 2 },
      { line: 37, code: 'int minVal = heap[0];', indent: 2 },
      { line: 38, code: 'heap[0] = heap.back();', indent: 2 },
      { line: 39, code: 'heap.pop_back();', indent: 2 },
      { line: 40, code: 'heapifyDown(0);', indent: 2 },
      { line: 41, code: 'return minVal;', indent: 2 },
      { line: 42, code: '}', indent: 1 },
      { line: 43, code: '};', indent: 0 },
    ],
    stepToLineMap: {
      'insert': [30, 31, 32],
      'heapifyUp': [5, 6, 7, 8, 9],
      'extractMin': [35, 36, 37, 38, 39, 40, 41],
      'heapifyDown': [13, 14, 15, 16, 18, 19, 20, 21, 23, 24, 25],
    }
  },
};

export function getDataStructureCode(algorithmId: string): AlgorithmCode | null {
  return dataStructureCodes[algorithmId] || null;
}
